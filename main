# =============================================================================
# --- MASTER SCRIPT: FIFA WORLD CUP 2026 PREDICTOR ---
# =============================================================================
import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt
import seaborn as sns
import os
from google.colab import drive

# 1. MOUNT DRIVE
if not os.path.exists('/content/drive'):
    drive.mount('/content/drive')

print("\n=== STEP 1: LOADING DATA ===")

# --- FILE PATHS (User Defined) ---
FORMER_NAMES_PATH = '/content/drive/MyDrive/FIFA ELO PROJECT/former_names.csv'
RESULTS_PATH = '/content/drive/MyDrive/FIFA ELO PROJECT/results.csv'
GOALS_PATH = '/content/drive/MyDrive/FIFA ELO PROJECT/goalscorers.csv'

# --- LOAD DATASETS ---
try:
    former_names_df = pd.read_csv(FORMER_NAMES_PATH)
    results_df = pd.read_csv(RESULTS_PATH)
    goalscorers_df = pd.read_csv(GOALS_PATH)
    print("âœ… All files loaded successfully.")
except FileNotFoundError as e:
    print(f"âŒ CRITICAL ERROR: {e}")
    print("Please check that your files are in the 'FIFA ELO PROJECT' folder on Google Drive.")
    exit()

# =============================================================================
# --- PART 1: ELO ENGINE & TEAM STATS ---
# =============================================================================
print("\n=== STEP 2: CALCULATING ELO RATINGS ===")

# 1. Clean Data
results_df['date'] = pd.to_datetime(results_df['date'])
results_df['home_team'] = results_df['home_team'].str.lower().str.strip()
results_df['away_team'] = results_df['away_team'].str.lower().str.strip()

# Apply Former Names Map
former_map = dict(zip(former_names_df['former'].str.lower(), former_names_df['current'].str.lower()))
results_df['home_team'] = results_df['home_team'].replace(former_map)
results_df['away_team'] = results_df['away_team'].replace(former_map)

# Filter for recent relevance (Elo builds up, but stats need recent data)
# We calculate Elo from full history to be accurate, but Off/Def strength from recent years
elo_df = results_df.sort_values('date').copy()

# 2. Elo Setup
team_elo = {}
INITIAL_RATING = 1200 # Slightly lower start for stability

def get_k(tournament, gd):
    k = 20 # Friendly
    if 'World Cup' in tournament: k = 60
    elif 'Continental' in tournament or 'Copa' in tournament or 'Euro' in tournament: k = 50
    elif 'Qualification' in tournament: k = 40
    
    # Goal Difference Multiplier
    if gd == 2: k *= 1.5
    elif gd == 3: k *= 1.75
    elif gd >= 4: k *= (1.75 + (gd-3)/8)
    return k

# 3. Run Elo Loop
for _, row in elo_df.iterrows():
    h, a = row['home_team'], row['away_team']
    hs, as_ = row['home_score'], row['away_score']
    
    rh = team_elo.get(h, INITIAL_RATING)
    ra = team_elo.get(a, INITIAL_RATING)
    
    # Calc Expected
    dr = rh - ra + 100 # +100 Home Advantage
    if row['neutral']: dr -= 100
    
    we = 1 / (10**(-dr/600) + 1)
    
    # Result
    if hs > as_: W = 1
    elif as_ > hs: W = 0
    else: W = 0.5
    
    # Update
    k = get_k(str(row['tournament']), abs(hs-as_))
    change = k * (W - we)
    
    team_elo[h] = rh + change
    team_elo[a] = ra - change

print(f"   Calculated ratings for {len(team_elo)} teams.")
print(f"   Top Team: {max(team_elo, key=team_elo.get).title()} ({int(max(team_elo.values()))} pts)")

# 4. Calculate Offensive/Defensive Strength (Last 4 Years Only)
recent_df = elo_df[elo_df['date'] > '2022-01-01']
avg_goals_global = (recent_df['home_score'].mean() + recent_df['away_score'].mean()) / 2

team_stats = {}
for team in team_elo.keys():
    games = recent_df[(recent_df['home_team'] == team) | (recent_df['away_team'] == team)]
    if len(games) < 5:
        off, def_ = 1.0, 1.0 # Default if no recent games
    else:
        gs = games[games['home_team']==team]['home_score'].sum() + games[games['away_team']==team]['away_score'].sum()
        gc = games[games['home_team']==team]['away_score'].sum() + games[games['away_team']==team]['home_score'].sum()
        matches = len(games)
        
        off = (gs / matches) / avg_goals_global
        def_ = (gc / matches) / avg_goals_global
    
    team_stats[team] = {'elo': team_elo[team], 'off': off, 'def': def_}

# =============================================================================
# --- PART 1.5: TACTICAL PROFILES  ---
# =============================================================================
print("\n=== STEP 3: BUILDING TACTICAL PROFILES ===")

# Clean Goalscorers Data
goalscorers_df['team'] = goalscorers_df['team'].str.lower().str.strip()
goalscorers_df['scorer'] = goalscorers_df['scorer'].str.strip()
goalscorers_df['penalty'] = goalscorers_df['penalty'].astype(str).str.upper() == 'TRUE'

def clean_min(m):
    try: return int(str(m).split('+')[0])
    except: return 0
goalscorers_df['clean_min'] = goalscorers_df['minute'].apply(clean_min)

# Profile Logic
team_profiles = {}
recent_goals = goalscorers_df[goalscorers_df['date'] > '2018-01-01'] # Modern Era

for team in team_elo.keys():
    t_goals = recent_goals[recent_goals['team'] == team]
    if len(t_goals) < 10:
        team_profiles[team] = 'Balanced'
        continue
        
    total = len(t_goals)
    late = len(t_goals[t_goals['clean_min'] >= 75])
    pens = len(t_goals[t_goals['penalty'] == True])
    
    # Hero Ball Check
    if not t_goals.empty:
        top_scorer_count = t_goals['scorer'].value_counts().iloc[0]
        hero_reliance = top_scorer_count / total
    else: hero_reliance = 0

    # Assign Style
    if hero_reliance > 0.30: style = "Hero Ball"
    elif (pens / total) > 0.15: style = "Dark Arts"
    elif (late / total) > 0.30: style = "Diesel Engine"
    elif (len(t_goals[t_goals['clean_min']<=20]) / total) > 0.25: style = "Blitzkrieg"
    else: style = "Balanced"
    
    team_profiles[team] = style

print("   Profiles Generated. Examples:")
for t in ['argentina', 'france', 'japan', 'england']:
    print(f"   - {t.title()}: {team_profiles.get(t, 'Unknown')}")

# =============================================================================
# --- PART 2: WORLD CUP SIMULATION ENGINE ---
# =============================================================================
print("\n=== STEP 4: INITIALIZING SIMULATOR ===")

# Style Matchup Bonus (Rock-Paper-Scissors Logic)
# Bonus represents extra goal probability (lambda multiplier)
STYLE_MATRIX = {
    ('Hero Ball', 'Balanced'): 1.05,     # Stars break organized defenses
    ('Balanced', 'Hero Ball'): 1.0,
    ('Diesel Engine', 'Blitzkrieg'): 1.1, # Fitness beats fast starters late
    ('Dark Arts', 'Hero Ball'): 1.05,     # Fouling the star player works
    ('Blitzkrieg', 'Dark Arts'): 1.1      # Score early before they can dive
}

def sim_match(t1, t2, knockout=False):
    # 1. Get Base Stats
    s1 = team_stats.get(t1, {'elo':1200, 'off':1.0, 'def':1.0})
    s2 = team_stats.get(t2, {'elo':1200, 'off':1.0, 'def':1.0})
    
    # 2. Elo Probability
    dr = s1['elo'] - s2['elo']
    we = 1 / (10**(-dr/600) + 1)
    
    # 3. Tactical Bonus
    style1 = team_profiles.get(t1, 'Balanced')
    style2 = team_profiles.get(t2, 'Balanced')
    
    # Apply modifier if matchup exists in matrix
    mod1 = STYLE_MATRIX.get((style1, style2), 1.0)
    mod2 = STYLE_MATRIX.get((style2, style1), 1.0)
    
    # 4. Expected Goals (Lambda)
    # Elo shift: If we > 0.5, you get more expected goals
    elo_scale = 1 + (we - 0.5)
    
    # Hosts Boost (USA/MEX/CAN)
    home_boost = 1.15 if t1 in ['usa', 'mexico', 'canada'] else 1.0
    away_boost = 1.15 if t2 in ['usa', 'mexico', 'canada'] else 1.0

    lam1 = avg_goals_global * s1['off'] * s2['def'] * elo_scale * mod1 * home_boost
    lam2 = avg_goals_global * s2['off'] * s1['def'] * (2 - elo_scale) * mod2 * away_boost
    
    # 5. Generate Score
    g1 = np.random.poisson(lam1)
    g2 = np.random.poisson(lam2)
    
    if g1 > g2: 
        if knockout: return t1, g1, g2, 'reg'
        return t1, g1, g2
    elif g2 > g1: 
        if knockout: return t2, g1, g2, 'reg'
        return t2, g1, g2
    else:
        if knockout:
            # Penalties: Dark Arts teams get a 10% bonus in PKs
            p1_bonus = 0.1 if style1 == 'Dark Arts' else 0
            p2_bonus = 0.1 if style2 == 'Dark Arts' else 0
            
            pk_prob = 0.5 + (dr/3000) + (p1_bonus - p2_bonus)
            winner = t1 if random.random() < pk_prob else t2
            return winner, g1, g2, 'pks'
        return 'draw', g1, g2

def simulate_tournament(verbose=True):
    # ==========================================
    # A. PLAYOFFS (March 2026)
    # ==========================================
    if verbose: print("\n=== MARCH 2026 PLAYOFFS ===")
    
    slots = {}
    
    # European Paths
    # We simulate a 'Final' for the path
    uefa_matches = [
        ('Path A', 'italy', 'turkey'), 
        ('Path B', 'ukraine', 'iceland'), 
        ('Path C', 'georgia', 'greece'), 
        ('Path D', 'wales', 'poland')
    ]
    
    for path, t1, t2 in uefa_matches:
        w, g1, g2, type_ = sim_match(t1, t2, knockout=True)
        slots[path] = w
        if verbose:
            method = "(PKs)" if type_ == 'pks' else ""
            print(f"  {path} Final: {t1.title()} {g1}-{g2} {t2.title()} {method} -> {w.title()} Qualifies")

    # Inter-confederation
    icp_matches = [('ICP1', 'chile', 'costa rica'), ('ICP2', 'iraq', 'panama')]
    for code, t1, t2 in icp_matches:
        w, g1, g2, type_ = sim_match(t1, t2, knockout=True)
        slots[code] = w
        if verbose:
            method = "(PKs)" if type_ == 'pks' else ""
            print(f"  {code} Final:   {t1.title()} {g1}-{g2} {t2.title()} {method} -> {w.title()} Qualifies")

    # ==========================================
    # B. GROUP STAGE
    # ==========================================
    groups = {
        'A': ['mexico', 'ivory coast', 'russia', slots['Path A']],
        'B': ['canada', 'switzerland', 'egypt', 'south korea'],
        'C': ['england', 'usa', 'serbia', 'new zealand'],
        'D': ['brazil', 'colombia', 'japan', slots['Path B']],
        'E': ['belgium', 'morocco', 'jamaica', 'austria'],
        'F': ['france', 'nigeria', 'australia', slots['Path C']],
        'G': ['spain', 'ecuador', 'south africa', 'iran'],
        'H': ['argentina', 'ukraine', 'mali', 'saudi arabia'], 
        'I': ['portugal', 'uruguay', 'qatar', slots['ICP1']],
        'J': ['germany', 'chile', 'cameroon', 'uzbekistan'],
        'K': ['netherlands', 'senegal', slots['ICP2'], 'croatia'],
        'L': ['italy', 'sweden', 'paraguay', 'honduras']
    }
    
    if verbose: print("\n=== GROUP STAGE ===")
    
    group_results = {}
    third_place = []
    
    for grp, teams in groups.items():
        if verbose: print(f"\n--- Group {grp} ---")
        table = {t: {'p':0, 'gd':0, 'gf':0} for t in teams}
        
        # Round Robin Logic
        for i in range(len(teams)):
            for j in range(i+1, len(teams)):
                t1, t2 = teams[i], teams[j]
                w, g1, g2 = sim_match(t1, t2)
                
                # Update Table
                table[t1]['gf'] += g1; table[t1]['gd'] += (g1-g2)
                table[t2]['gf'] += g2; table[t2]['gd'] += (g2-g1)
                
                if w == t1: table[t1]['p'] += 3
                elif w == t2: table[t2]['p'] += 3
                else: table[t1]['p'] += 1; table[t2]['p'] += 1
                
                # PRINT MATCH RESULT
                if verbose:
                    s1 = team_profiles.get(t1, 'Bal')
                    s2 = team_profiles.get(t2, 'Bal')
                    print(f"  {t1.title()} {g1}-{g2} {t2.title()}")

        # Sort Standings
        sorted_teams = sorted(teams, key=lambda t: (table[t]['p'], table[t]['gd']), reverse=True)
        group_results[grp] = sorted_teams
        
        # Save 3rd place stats
        third_place.append({'team': sorted_teams[2], 'stats': table[sorted_teams[2]]})
        
        if verbose:
            print(f"  > 1st: {sorted_teams[0].title()} ({table[sorted_teams[0]]['p']} pts)")
            print(f"  > 2nd: {sorted_teams[1].title()} ({table[sorted_teams[1]]['p']} pts)")

    # ==========================================
    # C. KNOCKOUT STAGE
    # ==========================================
    advancing = []
    for g in groups: advancing.extend(group_results[g][:2])
    
    # Calculate Best 3rd Place
    best_3rds = sorted(third_place, key=lambda x: (x['stats']['p'], x['stats']['gd']), reverse=True)[:8]
    advancing.extend([x['team'] for x in best_3rds])
    
    if verbose: 
        print(f"\n--- KNOCKOUT QUALIFIERS ({len(advancing)} Teams) ---")
        print(f"Best 3rd Place: {', '.join([t['team'].title() for t in best_3rds])}")

    # Seed the bracket by Elo
    seeded = sorted(advancing, key=lambda t: team_stats.get(t, {}).get('elo', 0), reverse=True)
    bracket = []
    n = len(seeded)
    for i in range(n//2):
        bracket.append((seeded[i], seeded[n-1-i]))
        
    rounds = ['Round of 32', 'Round of 16', 'Quarter-finals', 'Semi-finals', 'Final']
    champion = None
    third_winner = None
    
    for r in rounds:
        if verbose: print(f"\n=== {r.upper()} ===")
        next_round = []
        losers = []
        
        for t1, t2 in bracket:
            w, g1, g2, method = sim_match(t1, t2, knockout=True)
            note = f"({method})" if method == 'pks' else ""
            if verbose: 
                print(f"{t1.title()} {g1}-{g2} {t2.title()} {note} -> {w.title()}")
            next_round.append(w)
            if r == 'Semi-finals': losers.append(t2 if w == t1 else t1)
            
        if r == 'Semi-finals':
            w3, g1, g2, _ = sim_match(losers[0], losers[1], knockout=True)
            third_winner = w3
            if verbose: print(f"\nðŸ¥‰ 3rd Place Match: {losers[0].title()} {g1}-{g2} {losers[1].title()} -> {w3.title()}")

        if len(next_round) == 1: 
            champion = next_round[0]
        else:
            bracket = []
            for i in range(0, len(next_round), 2):
                if i+1 < len(next_round): bracket.append((next_round[i], next_round[i+1]))
                
    return champion, third_winner

# =============================================================================
# --- PART 3: MAIN MENU ---
# =============================================================================
def main():
    while True:
        print("\n" + "="*40)
        print("   FIFA WORLD CUP 2026 PREDICTOR")
        print("="*40)
        print("1. Run Single Detailed Simulation")
        print("2. Run 1,000 Simulations (Stats Mode)")
        print("3. View Team Profiles")
        print("4. Exit")
        
        c = input("Enter choice: ").strip()
        
        if c == '1':
            champ, third = simulate_tournament(verbose=True)
            print(f"\nðŸ† CHAMPION: {champ.title().upper()}")
            
        elif c == '2':
            print("Running 1,000 simulations...")
            counts = {}
            for i in range(1000):
                w, _ = simulate_tournament(verbose=False)
                counts[w] = counts.get(w, 0) + 1
                if i % 100 == 0: print(f"{i}...")
            
            # Show top 10
            leaderboard = sorted(counts.items(), key=lambda x: x[1], reverse=True)[:10]
            print("\n--- WIN PROBABILITY ---")
            for t, wins in leaderboard:
                print(f"{t.title()}: {wins/10}%")
                
        elif c == '3':
            t = input("Enter team name: ").lower()
            s = team_stats.get(t, None)
            p = team_profiles.get(t, 'Unknown')
            if s:
                print(f"\n--- {t.title()} ---")
                print(f"Elo: {int(s['elo'])}")
                print(f"Style: {p}")
                print(f"Offense: {s['off']:.2f}x avg")
                print(f"Defense: {s['def']:.2f}x avg")
            else:
                print("Team not found.")
                
        elif c == '4':
            break

if __name__ == "__main__":
    main()

